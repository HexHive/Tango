from . import debug, critical
from generator import ReactiveInputGenerator
from tracker import AbstractState
from input import AbstractInput, BaseDecorator
from profiler import CountProfiler, ValueProfiler
from mutator import ReactiveHavocMutator

class StatelessReactiveInputGenerator(ReactiveInputGenerator):
    def update_state(self, state: AbstractState, input: AbstractInput, *, orig_input: AbstractInput, exc: Exception=None, **kwargs):
        state = state.state_manager.state_tracker._entry_state
        super().update_state(state, input, orig_input=orig_input, exc=exc, **kwargs)

    def update_transition(self, source: AbstractState, destination: AbstractState, input: AbstractInput, *, state_changed: bool, orig_input: AbstractInput, exc: Exception=None, **kwargs):
        source = source.state_manager.state_tracker._entry_state
        if state_changed:
            assert source != destination, "No state change detected!"
            if (t := (source, destination)) in self._seen_transitions:
                # TODO handle case where mutator results in a seen transition
                return
            else:
                self._seen_transitions.add(t)

        if not orig_input.decorated:
            # input was not generated by us (e.g. seed input), ignore
            CountProfiler('undecorated_inputs')(1)
            return

        mut = orig_input.search_decorator_stack(lambda d: isinstance(d, ReactiveHavocMutator), max_depth=1)

        src_model = self._state_model[source]
        normalized_reward = self._calculate_reward(source, destination)
        if mut._actions_taken:
            self._update_weights(src_model['actions'], mut._actions, normalized_reward)

        if state_changed:
            # update feature counts
            fcount = self._count_features(source, destination)
            src_model['features'] += fcount

        if state_changed or mut._actions_taken:
            self._log_model(source)
