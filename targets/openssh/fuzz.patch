diff --git a/authfile.c b/authfile.c
index 9ed4f4c3..f5753a31 100644
--- a/authfile.c
+++ b/authfile.c
@@ -89,6 +89,7 @@ sshkey_save_private(struct sshkey *key, const char *filename,
 int
 sshkey_perm_ok(int fd, const char *filename)
 {
+#if 0
 	struct stat st;
 
 	if (fstat(fd, &st) == -1)
@@ -111,6 +112,7 @@ sshkey_perm_ok(int fd, const char *filename)
 		error("This private key will be ignored.");
 		return SSH_ERR_KEY_BAD_PERMISSIONS;
 	}
+#endif
 	return 0;
 }
 
diff --git a/cipher.c b/cipher.c
index 02aea408..6bfde9b4 100644
--- a/cipher.c
+++ b/cipher.c
@@ -75,7 +75,7 @@ struct sshcipher {
 #define CFLAG_CHACHAPOLY	(1<<1)
 #define CFLAG_AESCTR		(1<<2)
 #define CFLAG_NONE		(1<<3)
-#define CFLAG_INTERNAL		CFLAG_NONE /* Don't use "none" for packets */
+#define CFLAG_INTERNAL		CFLAG_NONE << 1 /* Don't use "none" for packets */
 #ifdef WITH_OPENSSL
 	const EVP_CIPHER	*(*evptype)(void);
 #else
diff --git a/dh.c b/dh.c
index ce2eb472..52dbbeda 100644
--- a/dh.c
+++ b/dh.c
@@ -280,6 +280,45 @@ dh_pub_is_valid(const DH *dh, const BIGNUM *dh_pub)
 	return 1;
 }
 
+typedef struct ffc_params_st {
+    /* Primes */
+    BIGNUM *p;
+    BIGNUM *q;
+    /* Generator */
+    BIGNUM *g;
+    /* DH X9.42 Optional Subgroup factor j >= 2 where p = j * q + 1 */
+    BIGNUM *j;
+
+    /* Required for FIPS186_4 validation of p, q and optionally canonical g */
+    unsigned char *seed;
+    /* If this value is zero the hash size is used as the seed length */
+    size_t seedlen;
+    /* Required for FIPS186_4 validation of p and q */
+    int pcounter;
+    int nid; /* The identity of a named group */
+
+    /*
+     * Required for FIPS186_4 generation & validation of canonical g.
+     * It uses unverifiable g if this value is -1.
+     */
+    int gindex;
+    int h; /* loop counter for unverifiable g */
+} FFC_PARAMS;
+
+typedef struct {
+    /*
+     * This first argument is used to pick up errors when a DH is passed
+     * instead of a EVP_PKEY
+     */
+    int pad;
+    int version;
+    FFC_PARAMS params;
+    int32_t length;             /* optional value of N (if there is no q) */
+    BIGNUM *pub_key;            /* g^x % p */
+    BIGNUM *priv_key;           /* x */
+    char reserved[];
+} DHfuzz;
+
 int
 dh_gen_key(DH *dh, int need)
 {
@@ -300,12 +339,19 @@ dh_gen_key(DH *dh, int need)
 	 */
 	if (!DH_set_length(dh, MINIMUM(need * 2, pbits - 1)))
 		return SSH_ERR_LIBCRYPTO_ERROR;
-
+#if 0
 	if (DH_generate_key(dh) == 0)
 		return SSH_ERR_LIBCRYPTO_ERROR;
 	DH_get0_key(dh, &pub_key, NULL);
 	if (!dh_pub_is_valid(dh, pub_key))
 		return SSH_ERR_INVALID_FORMAT;
+#else
+	DHfuzz *dhf = (DHfuzz *)dh;
+	if (dhf->priv_key == NULL)
+        dhf->priv_key = BN_new();
+    if (dhf->pub_key == NULL)
+        dhf->pub_key = BN_new();
+#endif
 	return 0;
 }
 
diff --git a/mac.c b/mac.c
index f3dda669..0b172503 100644
--- a/mac.c
+++ b/mac.c
@@ -219,8 +219,10 @@ mac_check(struct sshmac *mac, u_int32_t seqno,
 	if ((r = mac_compute(mac, seqno, data, dlen,
 	    ourmac, sizeof(ourmac))) != 0)
 		return r;
+#if 0
 	if (timingsafe_bcmp(ourmac, theirmac, mac->mac_len) != 0)
 		return SSH_ERR_MAC_INVALID;
+#endif
 	return 0;
 }
 
diff --git a/myproposal.h b/myproposal.h
index ee6e9f74..295c92b6 100644
--- a/myproposal.h
+++ b/myproposal.h
@@ -57,6 +57,7 @@
 	"rsa-sha2-256"
 
 #define	KEX_SERVER_ENCRYPT \
+	"none," \
 	"chacha20-poly1305@openssh.com," \
 	"aes128-ctr,aes192-ctr,aes256-ctr," \
 	"aes128-gcm@openssh.com,aes256-gcm@openssh.com"
diff --git a/openbsd-compat/arc4random.c b/openbsd-compat/arc4random.c
index ffd33734..41e6aa9e 100644
--- a/openbsd-compat/arc4random.c
+++ b/openbsd-compat/arc4random.c
@@ -40,7 +40,8 @@
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/time.h>
-
+#undef HAVE_ARC4RANDOM
+#undef HAVE_ARC4RANDOM_BUF
 #ifndef HAVE_ARC4RANDOM
 
 /*
@@ -208,11 +209,14 @@ _rs_random_u32(uint32_t *val)
 uint32_t
 arc4random(void)
 {
-	uint32_t val;
-
+	static uint32_t val = 0;
+#if 0
 	_ARC4_LOCK();
 	_rs_random_u32(&val);
 	_ARC4_UNLOCK();
+#else
+	++val;
+#endif
 	return val;
 }
 DEF_WEAK(arc4random);
@@ -225,9 +229,14 @@ DEF_WEAK(arc4random);
 void
 arc4random_buf(void *buf, size_t n)
 {
+#if 0
 	_ARC4_LOCK();
 	_rs_random_buf(buf, n);
 	_ARC4_UNLOCK();
+#else
+	static uint8_t c = 0;
+	memset(buf, ++c, n);
+#endif
 }
 DEF_WEAK(arc4random_buf);
 # endif /* !HAVE_ARC4RANDOM_BUF */
@@ -238,6 +247,7 @@ DEF_WEAK(arc4random_buf);
 void
 arc4random_buf(void *_buf, size_t n)
 {
+#if 0
 	size_t i;
 	u_int32_t r = 0;
 	char *buf = (char *)_buf;
@@ -249,6 +259,10 @@ arc4random_buf(void *_buf, size_t n)
 		r >>= 8;
 	}
 	explicit_bzero(&r, sizeof(r));
+#else
+	static uint8_t c = 0;
+	memset(buf, ++c, n);
+#endif
 }
 #endif /* !defined(HAVE_ARC4RANDOM_BUF) && defined(HAVE_ARC4RANDOM) */
 
diff --git a/openbsd-compat/arc4random_uniform.c b/openbsd-compat/arc4random_uniform.c
index 591f92d1..7fd9ce7f 100644
--- a/openbsd-compat/arc4random_uniform.c
+++ b/openbsd-compat/arc4random_uniform.c
@@ -24,7 +24,7 @@
 # include <stdint.h>
 #endif
 #include <stdlib.h>
-
+#undef HAVE_ARC4RANDOM_UNIFORM
 #ifndef HAVE_ARC4RANDOM_UNIFORM
 /*
  * Calculate a uniformly distributed random number less than upper_bound
diff --git a/sshd.c b/sshd.c
index 264e81ac..6412198c 100644
--- a/sshd.c
+++ b/sshd.c
@@ -128,6 +128,8 @@
 #include "srclimit.h"
 #include "dh.h"
 
+#include "rand.inc"
+
 /* Re-exec fds */
 #define REEXEC_DEVCRYPTO_RESERVED_FD	(STDERR_FILENO + 1)
 #define REEXEC_STARTUP_PIPE_FD		(STDERR_FILENO + 2)
@@ -233,7 +235,7 @@ static int *startup_flags = NULL;	/* Indicates child closed listener */
 static int startup_pipe = -1;		/* in child */
 
 /* variables used for privilege separation */
-int use_privsep = -1;
+int use_privsep = PRIVSEP_OFF;
 struct monitor *pmonitor = NULL;
 int privsep_is_preauth = 1;
 static int privsep_chroot = 1;
@@ -1558,6 +1560,8 @@ main(int ac, char **av)
 	struct connection_info *connection_info = NULL;
 	sigset_t sigmask;
 
+	FuzzerSetRand();
+
 #ifdef HAVE_SECUREWARE
 	(void)set_auth_parameters(ac, av);
 #endif
diff --git a/sshkey.c b/sshkey.c
index 43712253..a6ab2271 100644
--- a/sshkey.c
+++ b/sshkey.c
@@ -2122,6 +2122,7 @@ sshkey_verify(const struct sshkey *key,
     const u_char *data, size_t dlen, const char *alg, u_int compat,
     struct sshkey_sig_details **detailsp)
 {
+#if 0
 	const struct sshkey_impl *impl;
 
 	if (detailsp != NULL)
@@ -2132,6 +2133,9 @@ sshkey_verify(const struct sshkey *key,
 		return SSH_ERR_KEY_TYPE_UNKNOWN;
 	return impl->funcs->verify(key, sig, siglen, data, dlen,
 	    alg, compat, detailsp);
+#else
+	return 0;
+#endif
 }
 
 /* Convert a plain key to their _CERT equivalent */
